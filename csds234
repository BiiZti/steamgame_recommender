import tkinter as tk
from tkinter import ttk, messagebox
from pymongo import MongoClient
import json
from collections import Counter
from bson.objectid import ObjectId
import re

class GameRecommender:
    def __init__(self, root):
        self.root = root
        self.root.title("Game Recommendation System")
        self.root.geometry("1000x700")
        self.root.configure(bg='#f0f0f0')
        
        # Set style
        self.style = ttk.Style()
        self.style.configure('TFrame', background='#f0f0f0')
        self.style.configure('TLabel', background='#f0f0f0', font=('Arial', 10))
        self.style.configure('TButton', font=('Arial', 10))
        self.style.configure('TCheckbutton', background='#f0f0f0', font=('Arial', 10))
        self.style.configure('TRadiobutton', background='#f0f0f0', font=('Arial', 10))
        self.style.configure('TLabelframe', background='#f0f0f0', font=('Arial', 11, 'bold'))
        self.style.configure('TLabelframe.Label', background='#f0f0f0', font=('Arial', 11, 'bold'))
        
        # Connect to MongoDB
        self.connect_to_mongodb()
        
        # Initialize variables
        self.selected_platforms = []
        self.price_range = (0, 100)
        self.selected_games = []
        self.max_selections = 3
        self.game_checkboxes = {}
        
        # Create header
        self.create_header()
        
        # Create UI elements
        self.create_platform_selection()
        
    def connect_to_mongodb(self):
        try:
            # Use the SRV format as recommended in MongoDB Atlas
            connection_url = "mongodb+srv://G:WSGdsb123321.@ac-lsikpgh.wtghhj8.mongodb.net/?retryWrites=true&w=majority&appName=project234"
            
            # Connect with minimal options
            self.client = MongoClient(connection_url)
            self.db = self.client["steamDB"]
            self.collection = self.db["steam_games"]
            print("MongoDB connected successfully")
        except Exception as e:
            messagebox.showerror("Connection error", f"Failed to connect to MongoDB: {e}")
            print(f"MongoDB connection error: {e}")
    
    def create_header(self):
        header_frame = ttk.Frame(self.root)
        header_frame.pack(fill="x", padx=20, pady=10)
        
        title_label = tk.Label(
            header_frame,
            text="Game Recommendation System",
            font=('Arial', 16, 'bold'),
            bg='#f0f0f0',
            fg='#333333'
        )
        title_label.pack(pady=5)
        
        subtitle_label = tk.Label(
            header_frame,
            text="Find your next favorite game!",
            font=('Arial', 12),
            bg='#f0f0f0',
            fg='#666666'
        )
        subtitle_label.pack()
        
        separator = ttk.Separator(header_frame, orient='horizontal')
        separator.pack(fill='x', pady=10)
    
    def create_platform_selection(self):
        # Clear existing widgets
        for widget in self.root.winfo_children():
            if not isinstance(widget, ttk.Frame) or not widget.winfo_children():
                widget.destroy()
        
        # Create platform selection frame
        platform_frame = ttk.LabelFrame(self.root, text="Select Platforms")
        platform_frame.pack(padx=20, pady=20, fill="both", expand=True)
        
        # Add description
        desc_label = tk.Label(
            platform_frame,
            text="Choose the platforms you want to play on:",
            font=('Arial', 10),
            bg='#f0f0f0',
            fg='#333333'
        )
        desc_label.pack(pady=10)
        
        # Platform checkboxes with custom style
        self.windows_var = tk.BooleanVar()
        self.mac_var = tk.BooleanVar()
        self.linux_var = tk.BooleanVar()
        
        platforms = [
            ("Windows", self.windows_var),
            ("Mac", self.mac_var),
            ("Linux", self.linux_var)
        ]
        
        for platform, var in platforms:
            frame = ttk.Frame(platform_frame)
            frame.pack(pady=5, padx=20, fill="x")
            
            checkbox = ttk.Checkbutton(
                frame,
                text=platform,
                variable=var,
                style='TCheckbutton'
            )
            checkbox.pack(side="left")
        
        # Next button with custom style
        button_frame = ttk.Frame(platform_frame)
        button_frame.pack(pady=20)
        
        next_button = ttk.Button(
            button_frame,
            text="Next",
            command=self.create_price_selection,
            style='TButton'
        )
        next_button.pack(pady=10, ipadx=20, ipady=5)
    
    def create_price_selection(self):
        # Get selected platforms
        self.selected_platforms = []
        if self.windows_var.get():
            self.selected_platforms.append("windows")
        if self.mac_var.get():
            self.selected_platforms.append("mac")
        if self.linux_var.get():
            self.selected_platforms.append("linux")
        
        if not self.selected_platforms:
            messagebox.showwarning("Warning", "Please select at least one platform")
            return
        
        # Clear existing widgets
        for widget in self.root.winfo_children():
            if not isinstance(widget, ttk.Frame) or not widget.winfo_children():
                widget.destroy()
        
        # Create price range selection frame
        price_frame = ttk.LabelFrame(self.root, text="Select Price Range")
        price_frame.pack(padx=20, pady=20, fill="both", expand=True)
        
        # Add description
        desc_label = tk.Label(
            price_frame,
            text="Choose your preferred price range:",
            font=('Arial', 10),
            bg='#f0f0f0',
            fg='#333333'
        )
        desc_label.pack(pady=10)
        
        # Predefined price ranges with custom style
        price_ranges = [
            ("Free", (0, 0)),
            ("Under $10", (0, 10)),
            ("$10 - $20", (10, 20)),
            ("$20 - $30", (20, 30)),
            ("$30 - $40", (30, 40)),
            ("$40 - $50", (40, 50)),
            ("$50 and above", (50, 1000))
        ]
        
        self.price_var = tk.StringVar()
        for text, (min_price, max_price) in price_ranges:
            frame = ttk.Frame(price_frame)
            frame.pack(pady=5, padx=20, fill="x")
            
            radio = ttk.Radiobutton(
                frame,
                text=text,
                variable=self.price_var,
                value=f"{min_price}-{max_price}",
                style='TRadiobutton'
            )
            radio.pack(side="left")
        
        # Set default selection
        self.price_var.set("0-1000")
        
        # Get Recommendations button with custom style
        button_frame = ttk.Frame(price_frame)
        button_frame.pack(pady=20)
        
        rec_button = ttk.Button(
            button_frame,
            text="Get Recommendations",
            command=self.show_recommendations,
            style='TButton'
        )
        rec_button.pack(pady=10, ipadx=20, ipady=5)
    
    def calculate_game_weight(self, game, min_price, max_price):
        """Calculate weight score (0-10) based on price, peak_ccu, and positive rate"""
        try:
            # Get game attributes
            price = float(game.get('price', 100))  # Default to 100 if price is missing
            peak_ccu = int(game.get('peak_ccu', 0))
            positive = int(game.get('positive', 0))
            negative = int(game.get('negative', 0))
            
            # Calculate positive rate
            total_reviews = positive + negative
            positive_rate = positive / total_reviews if total_reviews > 0 else 0
            
            # Peak CCU: higher is better
            max_ccu = 100000  # Assuming max peak CCU is 100,000
            ccu_score = min(peak_ccu / max_ccu, 1)
            
            # Positive rate: higher is better
            positive_score = positive_rate
            
            # Check if price range is above $50
            if max_price > 50:
                # Exclude price from calculation, adjust weights
                weight = (ccu_score * 0.5 + positive_score * 0.5) * 10
            else:
                # Include price in calculation
                max_price = 100  # Assuming max price is $100
                price_score = 1 - (price / max_price) if price <= max_price else 0
                weight = (price_score * 0.4 + ccu_score * 0.3 + positive_score * 0.3) * 10
            
            return round(weight, 1)
        except Exception as e:
            print(f"Error calculating weight: {e}")
            return 0.0

    def show_recommendations(self):
        try:
            # Get price range
            min_price, max_price = map(float, self.price_var.get().split("-"))
            
            # Build query
            query = {
                "price": {"$gte": min_price, "$lte": max_price}
            }
            
            # Add platform conditions
            platform_conditions = []
            for platform in self.selected_platforms:
                platform_conditions.append({platform: "True"})
            
            if platform_conditions:
                query["$or"] = platform_conditions
            
            # Execute query and sort by peak_ccu
            results = self.collection.find(query).sort("peak_ccu", -1).limit(20)
            
            # Clear existing widgets
            for widget in self.root.winfo_children():
                if not isinstance(widget, ttk.Frame) or not widget.winfo_children():
                    widget.destroy()
            
            # Create results frame
            results_frame = ttk.LabelFrame(self.root, text="Select up to 3 games you like")
            results_frame.pack(padx=20, pady=20, fill="both", expand=True)
            
            # Add description
            desc_label = tk.Label(
                results_frame,
                text="Select the games you enjoy to get personalized recommendations:",
                font=('Arial', 10),
                bg='#f0f0f0',
                fg='#333333'
            )
            desc_label.pack(pady=10)
            
            # Create canvas and scrollbar for scrollable frame
            canvas = tk.Canvas(results_frame, bg='#f0f0f0', highlightthickness=0)
            scrollbar = ttk.Scrollbar(results_frame, orient="vertical", command=canvas.yview)
            scrollable_frame = ttk.Frame(canvas)
            
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)
            
            # Pack canvas and scrollbar
            canvas.pack(side="left", fill="both", expand=True, padx=10)
            scrollbar.pack(side="right", fill="y")
            
            # Clear previous checkboxes
            self.game_checkboxes.clear()
            
            # Add results to scrollable frame
            for game in results:
                game_frame = ttk.Frame(scrollable_frame)
                game_frame.pack(fill="x", padx=5, pady=5)
                
                # Calculate weight for this game
                weight = self.calculate_game_weight(game, min_price, max_price)
                
                # Create checkbox
                var = tk.BooleanVar()
                self.game_checkboxes[str(game.get("_id"))] = var
                
                # Create a frame for the checkbox and game details
                content_frame = ttk.Frame(game_frame)
                content_frame.pack(fill="x", expand=True)
                
                # Create checkbox with custom style
                checkbox = ttk.Checkbutton(
                    content_frame,
                    text=game.get("name", "Unknown"),
                    variable=var,
                    command=lambda gid=str(game.get("_id")): self.update_selection_count(gid),
                    style='TCheckbutton'
                )
                checkbox.pack(side="left", padx=5)
                
                # Add game details
                details_frame = ttk.Frame(content_frame)
                details_frame.pack(side="left", fill="x", expand=True, padx=10)
                
                # First row: Basic details
                basic_details = f"Price: ${game.get('price', 0)} | Peak CCU: {game.get('peak_ccu', 0)}"
                
                # Calculate positive rate
                positive = game.get("positive", 0)
                negative = game.get("negative", 0)
                if positive + negative > 0:
                    positive_rate = f"{positive / (positive + negative) * 100:.1f}%"
                else:
                    positive_rate = "N/A"
                basic_details += f" | Positive Rate: {positive_rate}"
                
                ttk.Label(details_frame, text=basic_details).pack(anchor="w")
                
                # Second row: Tags
                tags_text = "Tags: "
                try:
                    tags = game.get("tags", "")
                    if tags:
                        tag_str = tags.replace("'", "\"")
                        tag_dict = json.loads(tag_str)
                        tags_text += ", ".join(list(tag_dict.keys())[:5])
                    else:
                        tags_text += "None"
                except:
                    tags_text += "None"
                
                ttk.Label(details_frame, text=tags_text).pack(anchor="w")
                
                # Third row: Weight Score
                weight_text = f"Weight Score: {weight}/10"
                weight_label = tk.Label(
                    details_frame,
                    text=weight_text,
                    font=('Arial', 9, 'bold'),
                    bg='#f0f0f0',
                    fg='#2c5282'
                )
                weight_label.pack(anchor="w")
                
                # Add separator
                separator = ttk.Separator(game_frame, orient='horizontal')
                separator.pack(fill='x', pady=5)
            
            # Add selection count label
            self.selection_count_label = tk.Label(
                results_frame,
                text="Selected: 0/3",
                font=('Arial', 10, 'bold'),
                bg='#f0f0f0',
                fg='#2c5282'
            )
            self.selection_count_label.pack(pady=5)
            
            # Add buttons
            button_frame = ttk.Frame(results_frame)
            button_frame.pack(pady=10)
            
            get_similar_button = ttk.Button(
                button_frame,
                text="Get Similar Games",
                command=self.show_similar_games,
                style='TButton'
            )
            get_similar_button.pack(side=tk.LEFT, padx=5, ipadx=20, ipady=5)
            
            start_over_button = ttk.Button(
                button_frame,
                text="Start Over",
                command=self.create_platform_selection,
                style='TButton'
            )
            start_over_button.pack(side=tk.LEFT, padx=5, ipadx=20, ipady=5)
            
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {e}")
            print(f"Error in show_recommendations: {e}")
            import traceback
            traceback.print_exc()
    
    def update_selection_count(self, game_id_str):
        # Count selected games
        selected_count = sum(1 for var in self.game_checkboxes.values() if var.get())
        
        if selected_count > self.max_selections:
            # Uncheck the last selected game
            self.game_checkboxes[game_id_str].set(False)
            selected_count = self.max_selections
            messagebox.showwarning("Warning", f"You can only select up to {self.max_selections} games")
        
        self.selection_count_label.config(text=f"Selected: {selected_count}/{self.max_selections}")
    
    def show_similar_games(self):
        try:
            # Get selected game IDs (as strings)
            selected_game_id_strs = [game_id_str for game_id_str, var in self.game_checkboxes.items() if var.get()]
            
            if not selected_game_id_strs:
                messagebox.showwarning("Warning", "Please select at least one game")
                return
            
            # Convert string IDs to ObjectIds
            selected_object_ids = []
            for game_id_str in selected_game_id_strs:
                try:
                    selected_object_ids.append(ObjectId(game_id_str))
                except Exception as e:
                    print(f"Error converting ID {game_id_str} to ObjectId: {e}")
                    continue # Skip invalid IDs
            
            # Fetch game details using the ObjectIds
            selected_games = []
            if selected_object_ids:
                selected_games_cursor = self.collection.find({"_id": {"$in": selected_object_ids}})
                selected_games = list(selected_games_cursor)
            
            # Double check if games were found (might fail if IDs were invalid)
            if not selected_games:
                 messagebox.showerror("Error", "Could not retrieve details for selected games.")
                 return
            
            # Collect all tags from selected games
            all_tags = []
            for game in selected_games:
                tags = game.get("tags", "")
                if tags:
                    try:
                        # Ensure tags are treated as a dictionary string
                        tag_str = tags.replace("'", "\"")
                        tag_dict = json.loads(tag_str)
                        all_tags.extend(tag_dict.keys())
                    except (json.JSONDecodeError, TypeError) as e:
                        print(f"Error parsing tags for game {game.get('name')}: {e}")
                        continue
            
            if not all_tags:
                 messagebox.showinfo("Info", "No common tags found among selected games to find similar ones.")
                 return
            
            # Count tag occurrences
            tag_counter = Counter(all_tags)
            # Get top 5 most common tags
            top_tags = [tag for tag, _ in tag_counter.most_common(5)]
            
            # --- Add previous filters --- 
            # Get price range from the variable set in create_price_selection
            min_price, max_price = map(float, self.price_var.get().split("-"))
            
            # Get selected platforms from the instance variable
            platforms_to_filter = self.selected_platforms
            # --- End Add previous filters --- 

            # Build query for similar games
            query = {
                # Use the list of ObjectIds directly
                "_id": {"$nin": selected_object_ids},
                # Ensure tags are properly escaped for regex if needed
                "tags": {"$regex": "|".join(map(re.escape, top_tags)), "$options": "i"}, # Case-insensitive search
                # Add price filter
                "price": {"$gte": min_price, "$lte": max_price}
            }
            
            # Add platform conditions (same as in show_recommendations)
            platform_conditions = []
            for platform in platforms_to_filter:
                platform_conditions.append({platform: "True"})
            
            if platform_conditions:
                query["$or"] = platform_conditions
            # --- End integrating filters into query ---
            
            # Execute query and sort by peak_ccu
            results = self.collection.find(query).sort("peak_ccu", -1).limit(10)
            
            # Create new window for similar games
            similar_window = tk.Toplevel(self.root)
            similar_window.title("Similar Games")
            similar_window.geometry("800x600")
            
            # Create results frame
            results_frame = ttk.LabelFrame(similar_window, text=f"Games similar to your selections")
            results_frame.pack(padx=20, pady=20, fill="both", expand=True)
            
            # Display the top tags being used for recommendation
            tags_frame = ttk.Frame(results_frame)
            tags_frame.pack(fill="x", padx=5, pady=5)
            ttk.Label(tags_frame, text="Recommended based on tags: " + ", ".join(top_tags)).pack(anchor="w")
            
            # Create canvas and scrollbar for scrollable frame
            canvas = tk.Canvas(results_frame)
            scrollbar = ttk.Scrollbar(results_frame, orient="vertical", command=canvas.yview)
            scrollable_frame = ttk.Frame(canvas)
            
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)
            
            # Pack canvas and scrollbar
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            
            # First, display the selected games
            selected_games_frame = ttk.LabelFrame(scrollable_frame, text="Your Selected Games")
            selected_games_frame.pack(fill="x", padx=5, pady=5)
            
            for game in selected_games:
                game_frame = ttk.Frame(selected_games_frame)
                game_frame.pack(fill="x", padx=5, pady=5)
                
                # Add game name with bold font
                game_name = tk.Label(game_frame, text=game.get('name', 'Unknown'), font=("Arial", 10, "bold"))
                game_name.pack(side="left", padx=5)
                
                # Basic details 
                basic_details = f"Price: ${game.get('price', 0)} | Peak CCU: {game.get('peak_ccu', 0)}"
                
                # Calculate positive rate
                positive = game.get("positive", 0)
                negative = game.get("negative", 0)
                if positive + negative > 0:
                    positive_rate = f"{positive / (positive + negative) * 100:.1f}%"
                else:
                    positive_rate = "N/A"
                basic_details += f" | Positive Rate: {positive_rate}"
                
                ttk.Label(game_frame, text=basic_details).pack(side="left", padx=5)
                
                # Tags
                tags_text = "Tags: "
                try:
                    tags = game.get("tags", "")
                    if tags:
                        tag_str = tags.replace("'", "\"")
                        tag_dict = json.loads(tag_str)
                        tags_text += ", ".join(list(tag_dict.keys())[:5])  # Show first 5 tags
                    else:
                        tags_text += "None"
                except:
                    tags_text += "None"
                
                ttk.Label(game_frame, text=tags_text).pack(side="left", padx=5)
            
            # Add a separator between selected games and recommendations
            ttk.Separator(scrollable_frame, orient="horizontal").pack(fill="x", pady=10)
            
            # Now display the recommended games
            recommendations_frame = ttk.LabelFrame(scrollable_frame, text="Recommended Games")
            recommendations_frame.pack(fill="x", padx=5, pady=5)
            
            # Add results to scrollable frame
            similar_game_count = 0
            for game in results:
                similar_game_count += 1
                game_frame = ttk.Frame(recommendations_frame)
                game_frame.pack(fill="x", padx=5, pady=5)
                
                # Create a frame for game details
                details_frame = ttk.Frame(game_frame)
                details_frame.pack(fill="x", expand=True, padx=10)
                
                # Add game name with bold font
                game_name = tk.Label(details_frame, text=game.get('name', 'Unknown'), font=("Arial", 10, "bold"))
                game_name.pack(anchor="w")
                
                # Basic details row
                basic_details = f"Price: ${game.get('price', 0)} | Peak CCU: {game.get('peak_ccu', 0)}"
                
                # Calculate positive rate
                positive = game.get("positive", 0)
                negative = game.get("negative", 0)
                if positive + negative > 0:
                    positive_rate = f"{positive / (positive + negative) * 100:.1f}%"
                else:
                    positive_rate = "N/A"
                basic_details += f" | Positive Rate: {positive_rate}"
                
                ttk.Label(details_frame, text=basic_details).pack(anchor="w")
                
                # Tags row
                tags_text = "Tags: "
                try:
                    tags = game.get("tags", "")
                    if tags:
                        tag_str = tags.replace("'", "\"")
                        tag_dict = json.loads(tag_str)
                        tags_text += ", ".join(list(tag_dict.keys())[:5])  # Show first 5 tags
                    else:
                        tags_text += "None"
                except:
                    tags_text += "None"
                
                ttk.Label(details_frame, text=tags_text).pack(anchor="w")
                
                # Weight Score row
                weight = self.calculate_game_weight(game, min_price, max_price)
                weight_text = f"Weight Score: {weight}/10"
                ttk.Label(details_frame, text=weight_text, font=("Arial", 9, "bold")).pack(anchor="w")
                
                # Add separator
                ttk.Separator(recommendations_frame, orient="horizontal").pack(fill="x", pady=5)
            
            if similar_game_count == 0:
                ttk.Label(recommendations_frame, text="No similar games found based on the tags.").pack(pady=10)
            
            # Add close button
            ttk.Button(results_frame, text="Close", command=similar_window.destroy).pack(pady=20, side=tk.BOTTOM)
            
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred while fetching similar games: {e}")
            # Print detailed error for debugging
            import traceback
            traceback.print_exc()

if __name__ == "__main__":
    root = tk.Tk()
    app = GameRecommender(root)
    root.mainloop() 